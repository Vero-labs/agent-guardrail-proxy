package analyzer

import (
	"regexp"
)

// MalwareScanner detects potentially malicious code patterns in generated output
type MalwareScanner struct {
	patterns map[string][]*regexp.Regexp
}

// Malware pattern categories
const (
	MalwareCatExecution    = "code_execution"    // eval, exec, os.system
	MalwareCatObfuscated   = "obfuscated_code"   // Base64, hex encoded payloads
	MalwareCatShellcode    = "shellcode"         // Shellcode patterns
	MalwareCatExfiltration = "data_exfiltration" // Data exfiltration patterns
	MalwareCatInjection    = "injection"         // SQL/command injection
)

// NewMalwareScanner creates a new MalwareScanner with detection patterns
func NewMalwareScanner() *MalwareScanner {
	patterns := make(map[string][]*regexp.Regexp)

	// Code Execution patterns
	patterns[MalwareCatExecution] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)\beval\s*\(`),
		regexp.MustCompile(`(?i)\bexec\s*\(`),
		regexp.MustCompile(`(?i)os\.system\s*\(`),
		regexp.MustCompile(`(?i)subprocess\.(run|call|Popen|check_output)\s*\(`),
		regexp.MustCompile(`(?i)child_process\.(exec|spawn)\s*\(`),
		regexp.MustCompile(`(?i)Runtime\.getRuntime\(\)\.exec\(`),
		regexp.MustCompile(`(?i)__import__\s*\(`),
		regexp.MustCompile(`(?i)importlib\.import_module\s*\(`),
	}

	// Obfuscated code patterns
	patterns[MalwareCatObfuscated] = []*regexp.Regexp{
		// Base64 encoded strings (common in payloads)
		regexp.MustCompile(`(?i)base64\.(b64decode|decode|decodebytes)\s*\(`),
		regexp.MustCompile(`(?i)atob\s*\(`),
		regexp.MustCompile(`(?i)Buffer\.from\([^)]+,\s*['"]base64['"]\)`),
		// Hex encoded strings
		regexp.MustCompile(`(?i)bytes\.fromhex\s*\(`),
		regexp.MustCompile(`\\x[0-9a-fA-F]{2}(\\x[0-9a-fA-F]{2}){10,}`), // Long hex sequences
		// Char code obfuscation
		regexp.MustCompile(`(?i)String\.fromCharCode\([^)]{20,}\)`),
	}

	// Shellcode patterns
	patterns[MalwareCatShellcode] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)\b(nopsled|nop\s*sled)\b`),
		regexp.MustCompile(`(?i)0x90{4,}`), // NOP slides
		regexp.MustCompile(`(?i)\bshellcode\b`),
		regexp.MustCompile(`(?i)msfvenom`),
		regexp.MustCompile(`(?i)/bin/sh`),
		regexp.MustCompile(`(?i)\bexecve\b`),
	}

	// Data exfiltration patterns
	patterns[MalwareCatExfiltration] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)curl\s+.+\|`),
		regexp.MustCompile(`(?i)wget\s+.+\|`),
		regexp.MustCompile(`(?i)nc\s+-[el]`), // netcat listener/connect
		regexp.MustCompile(`(?i)base64.*\|\s*(curl|wget|nc)`),
		regexp.MustCompile(`(?i)document\.cookie`),
		regexp.MustCompile(`(?i)localStorage\.(getItem|setItem)`),
	}

	// Injection patterns
	patterns[MalwareCatInjection] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)'\s*OR\s+'1'\s*=\s*'1`),
		regexp.MustCompile(`(?i);\s*DROP\s+TABLE\b`),
		regexp.MustCompile(`(?i)UNION\s+SELECT\b`),
		regexp.MustCompile(`(?i);\s*--`),
		regexp.MustCompile(`(?i)\$\([^)]+\)`), // Command substitution
	}

	return &MalwareScanner{patterns: patterns}
}

// MalwareSignal represents a detected malware pattern
type MalwareSignal struct {
	Category string `json:"category"`
	Pattern  string `json:"pattern"`
	Match    string `json:"match"`
	Severity string `json:"severity"` // "critical", "high", "medium"
}

// Scan checks text for malware patterns and returns all detected signals
func (s *MalwareScanner) Scan(text string) []MalwareSignal {
	var signals []MalwareSignal

	for category, regexes := range s.patterns {
		for _, pattern := range regexes {
			matches := pattern.FindAllString(text, 3) // Limit to 3 matches per pattern
			for _, match := range matches {
				signals = append(signals, MalwareSignal{
					Category: category,
					Pattern:  pattern.String()[:min(50, len(pattern.String()))],
					Match:    truncate(match, 100),
					Severity: getSeverity(category),
				})
			}
		}
	}

	return signals
}

// HasMalware returns true if any malware patterns are detected
func (s *MalwareScanner) HasMalware(text string) bool {
	for _, regexes := range s.patterns {
		for _, pattern := range regexes {
			if pattern.MatchString(text) {
				return true
			}
		}
	}
	return false
}

// HasCriticalMalware returns true if critical malware patterns are detected
func (s *MalwareScanner) HasCriticalMalware(text string) bool {
	criticalCategories := []string{MalwareCatShellcode, MalwareCatExecution}
	for _, cat := range criticalCategories {
		if patterns, ok := s.patterns[cat]; ok {
			for _, pattern := range patterns {
				if pattern.MatchString(text) {
					return true
				}
			}
		}
	}
	return false
}

func getSeverity(category string) string {
	switch category {
	case MalwareCatShellcode, MalwareCatExecution:
		return "critical"
	case MalwareCatExfiltration, MalwareCatInjection:
		return "high"
	default:
		return "medium"
	}
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}
